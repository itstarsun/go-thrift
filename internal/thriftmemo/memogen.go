//go:build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"reflect"
	"strings"

	"github.com/itstarsun/go-thrift/encoding/thriftwire"
)

func main() {
	var g generator
	g.generate()
	err := os.WriteFile("zmemo.go", g.format(), 0666)
	if err != nil {
		log.Fatal(err)
	}
}

type generator struct {
	bytes.Buffer
}

func (g *generator) printf(format string, args ...any) {
	fmt.Fprintf(&g.Buffer, format, args...)
}

func (g *generator) format() []byte {
	src, err := format.Source(g.Bytes())
	if err != nil {
		src = g.Bytes()
	}
	return src
}

func (g *generator) generate() {
	g.printf("// Code generated by %q; DO NOT EDIT.\n\n", "go run tmemogen.go")
	g.printf("package thriftmemo\n\n")
	g.printf("import (\n")
	g.printf("%q\n", "io")
	g.printf("\n")
	g.printf("%q\n", "github.com/itstarsun/go-thrift/encoding/thriftwire")
	g.printf(")\n\n")

	g.generateReader()
	g.generateWriter()
}

func (g *generator) generateMethod(recv string, m reflect.Method) {
	g.printf("func (%s) %s(", recv, m.Name)
	for i := 0; i < m.Type.NumIn(); i++ {
		if i > 0 {
			g.printf(", ")
		}
		g.printf("i%d %s", i, typeString(m.Type.In(i)))
	}
	g.printf(")")
	if m.Type.NumOut() > 0 {
		g.printf(" (")
		for i := 0; i < m.Type.NumOut(); i++ {
			if i > 0 {
				g.printf(", ")
			}
			g.printf("o%d %s", i, typeString(m.Type.Out(i)))
		}
		g.printf(")")
	}
}

func typeString(t reflect.Type) string {
	return strings.ReplaceAll(t.String(), "uint8", "byte")
}

var errorType = reflect.TypeOf((*error)(nil)).Elem()

func (g *generator) generateAdvance(m reflect.Method) {
	errorOut := m.Type.NumOut() - 1
	if errorOut < 0 || !m.Type.Out(errorOut).Implements(errorType) {
		panic("invalid method: " + m.Type.String())
	}
	g.printf("if o%d = m.advance(); o%[1]d != nil {\n", errorOut)
	g.printf("return\n")
	g.printf("}\n")
}

func (g *generator) generateReader() {
	t := reflect.TypeOf((*thriftwire.Reader)(nil)).Elem()
	for i := 0; i < t.NumMethod(); i++ {
		m := t.Method(i)
		g.generateMethod("m *memoReader", m)
		g.printf("{\n")
		if step, ok := strings.CutPrefix(m.Name, "Read"); ok {
			g.generateAdvance(m)
			if step == "UUID" {
				g.printf("m.memo().read(%q, i0)\n", step)
			} else {
				g.printf("m.memo().read(%q", step)
				for i := 0; i < m.Type.NumOut()-1; i++ {
					g.printf(", &o%d", i)
				}
				g.printf(")\n")
			}
			g.printf("return\n")
		} else if step, ok := strings.CutPrefix(m.Name, "Skip"); ok {
			g.generateAdvance(m)
			switch step {
			case "String":
				g.printf("var tmp string\n")
			case "UUID":
				g.printf("var tmp [16]byte\n")
			default:
				panic("unknown step: " + step)
			}
			g.printf("m.memo().read(%q, &tmp)\n", step)
			g.printf("return\n")
		} else {
			g.printf("panic(%q)\n", "unsupported")
		}
		g.printf("}\n\n")
	}
}

func (g *generator) generateWriter() {
	t := reflect.TypeOf((*thriftwire.Writer)(nil)).Elem()
	for i := 0; i < t.NumMethod(); i++ {
		m := t.Method(i)
		g.generateMethod("m *memoWriter", m)
		g.printf("{\n")
		if step, ok := strings.CutPrefix(m.Name, "Write"); ok {
			g.generateAdvance(m)
			if step == "StructEnd" {
				g.printf("m.memo().write(%q, %#v)\n", "FieldBegin", thriftwire.FieldHeader{Type: thriftwire.Stop})
				g.generateAdvance(m)
				g.printf("m.memo().write(%q)\n", step)
			} else if step == "UUID" {
				g.printf("m.memo().write(%q, *i0)\n", step)
			} else {
				g.printf("m.memo().write(%q", step)
				for i, j := 0, m.Type.NumIn(); i < j; i++ {
					g.printf(", i%d", i)
				}
				g.printf(")\n")
			}
			g.printf("return\n")
		} else {
			g.printf("panic(%q)\n", "unsupported")
		}
		g.printf("}\n\n")
	}
}
